Date.prototype.setISO8601 = function (string) {
    var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})" +
        "(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?" +
        "(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";
    var d = string.match(new RegExp(regexp));

    var offset = 0;
    var date = new Date(d[1], 0, 1);

    if (d[3]) { date.setMonth(d[3] - 1); }
    if (d[5]) { date.setDate(d[5]); }
    if (d[7]) { date.setHours(d[7]); }
    if (d[8]) { date.setMinutes(d[8]); }
    if (d[10]) { date.setSeconds(d[10]); }
    if (d[12]) { date.setMilliseconds(Number("0." + d[12]) * 1000); }
    if (d[14]) {
        offset = (Number(d[16]) * 60) + Number(d[17]);
        offset *= ((d[15] == '-') ? 1 : -1);
    }

    offset -= date.getTimezoneOffset();
    time = (Number(date) + (offset * 60 * 1000));
    this.setTime(Number(time));
    return this;
}
// Implemented by Rob Fuller at the Irish Marine Institute, standing on the shoulders of giants.
var currentTime = new Date();
currentTime.setUTCHours(0, 0, 0, 0);
var endDate = new Date(currentTime.getTime());
L.TimeDimension.Util.addTimeDuration(endDate, "PT60H", true);      

var map = L.map('map', {
    zoom: 10,
    crs: L.CRS.EPSG4326,
    center: [53.3, -9.59],
    fullscreenControl: true,
    timeDimensionControl: true,
    timeDimension: true,
    timeDimensionOptions: {
        timeInterval: "P1W/" + endDate.toISOString(),
        period: "PT2H",
        currentTime: currentTime.getTime()
    },
    timeDimensionControlOptions: {    
        playerOptions: {                        
            loop: true,
            transitionTime: 1000,
            buffer: 10
        }
    }
});
 map.on("click",function(e){
       var layers = e.target._layers;
       var keys = Object.keys(layers).reverse();
       for(var i=0;i<keys.length;i++){
          if(layers[keys[i]].options === undefined){
             continue;
          }
          var erddap_options = layers[keys[i]].options.erddap;
          if(erddap_options !== undefined && erddap_options.meta !== undefined){
             var meta = erddap_options.meta;
             var lat = e.latlng.lat, lng =  e.latlng.lng, ncg = meta.attribute.NC_GLOBAL;
             var latmin = parseFloat(ncg.geospatial_lat_min.value),
                 latmax = parseFloat(ncg.geospatial_lat_max.value),
                 lngmin = parseFloat(ncg.geospatial_lon_min.value),
                 lngmax = parseFloat(ncg.geospatial_lon_max.value);
             if(lat>=latmin && lat <= latmax && lng>=lngmin && lng <= lngmax){
               showPointChart(layers[keys[i]],erddap_options,e);
               break;
             }
          }
       }
  });

var erddap = "http://erddap.marine.ie/erddap";
var dataset = "IMI_CONN_3D";
var connWMS = erddap+"/wms/"+dataset+"/request";
var attribute = 'Sea_water_temperature';
var conn3TemperatureLayer = L.tileLayer.wms(connWMS, {
    layers: dataset+':'+attribute,
    format: 'image/png',
    transparent: true,    
    abovemaxcolor: "extend",
    belowmincolor: "extend",
    numcolorbands: 40,
    zIndex: 1,
    crs: L.CRS.EPSG4326,
    erddap:{
        url: erddap,
        dataset: dataset,
        attributes: [attribute],
        altitude: "20.0"
    },
});

attribute = 'Sea_water_salinity';
var conn3SalinityLayer = L.tileLayer.wms(connWMS, {
    layers: dataset+':'+attribute,
    format: 'image/png',
    transparent: true,    
    abovemaxcolor: "extend",
    belowmincolor: "extend",
    numcolorbands: 40,
    crs: L.CRS.EPSG4326,
    erddap:{
        url: erddap,
        dataset: dataset,
        attributes: [attribute],
        altitude: "20.0"
    },
});
var conn3VelocityLayer = L.tileLayer.wms( "http://erddap3.marine.ie/erddap/wms/"+dataset+"/request", {
    layers: dataset+':vectors[sea_water_x_velocity|sea_water_y_velocity]',
    format: 'image/png',
    transparent: true,    
    crs: L.CRS.EPSG4326,
    erddap:{
        url: erddap,
        dataset: dataset,
        attributes: ['sea_water_x_velocity','sea_water_y_velocity'],
        altitude: "20.0"
    },
});

var overlayMaps = { };

var baseLayers = getCommonBaseLayers(map); // see baselayers.js
var layersControl = L.control.layers(baseLayers, overlayMaps);
layersControl.addTo(map);
L.control.coordinates({
    position: "bottomright",
    decimals: 3,
    labelTemplateLat: "Latitude: {y}",
    labelTemplateLng: "Longitude: {x}",
    useDMS: false,
    enableUserInput: false
}).addTo(map);

var legend = L.control({position: 'bottomright'});

legend.onAdd = function (map) {
	var div = L.DomUtil.create('div', 'info');
         div.innerHTML += '<img width="275px" id="erddapLegend" alt="legend" src="">';
	return div;
};
legend.addTo(map);

var addTimeDimensionLayer = function(layer, name, addToMap){
    var timeDimensionLayer = L.timeDimension.layer.wms(layer, {});
    layersControl.addOverlay(timeDimensionLayer, name);
    if (addToMap)
        timeDimensionLayer.addTo(map);
    timeDimensionLayer.on("timeload", (function(layer){
      var erddap = layer.options.erddap;
      var t = layer.options.time;
      var img = new Image();
      img.onload = (function(image){
         document.getElementById("erddapLegend").src = image.src;
      }).bind(null,img);
      var a = "";
      for(var i=0;i<erddap.attributes.length;i++){
         if(i>0){
            a = a + ",";
         }
         a = a + erddap.attributes[i]+"[("+t+")][("+erddap.altitude+")][][]";
      }
      img.src = erddap.url+"/griddap/"+erddap.dataset+".transparentPng?"+a+"&.legend=Only";
    }).bind(null,layer));
}
var rows2oo = function(data){
  var info = {};
  var rows = data["table"]["rows"];
  for(var i=0;i<rows.length;i++){
    if(info[rows[i][0]] === undefined){
       info[rows[i][0]] = {};
    }
    if(info[rows[i][0]][rows[i][1]] === undefined){
       info[rows[i][0]][rows[i][1]] = {};
    }
    info[rows[i][0]][rows[i][1]][rows[i][2]] = {type: rows[i][3], value: rows[i][4]};
  }
  return info;

};

$.getJSON(erddap+"/info/"+dataset+"/index.json", function(data){
    var info = rows2oo(data);
    console.log(info.attribute);
    var colorscalerange = info.attribute.Sea_water_temperature.colorBarMinimum.value + "," +
         info.attribute.Sea_water_temperature.colorBarMaximum.value;
    conn3TemperatureLayer.options.colorscalerange = colorscalerange;
    conn3TemperatureLayer.wmsParams.colorscalerange = colorscalerange;
    conn3TemperatureLayer.options.erddap.meta = info;
    addTimeDimensionLayer(conn3TemperatureLayer, 'CONN - Temperature', true);

    addTimeDimensionLayer(conn3SalinityLayer, 'CONN - Salinity', false);
    colorscalerange = info.attribute.Sea_water_salinity.colorBarMinimum.value + "," +
         info.attribute.Sea_water_salinity.colorBarMaximum.value;
    conn3SalinityLayer.options.colorscalerange = colorscalerange;
    conn3SalinityLayer.options.erddap.meta = info;
    conn3SalinityLayer.wmsParams.colorscalerange = colorscalerange;

    addTimeDimensionLayer(conn3VelocityLayer, 'CONN - Velocity', true);

});
var showPointChart = function(layer,options,e){
    var start_time = options.meta.attribute.NC_GLOBAL.time_coverage_start.value,
        end_time =  options.meta.attribute.NC_GLOBAL.time_coverage_end.value,
        lat = e.latlng.lat,
        lng =  e.latlng.lng;
    var width = 400;
    var height = 300;
    var url = options.url+"/griddap/"+options.dataset+".csv?"+options.attributes[0]+"[("+start_time+"):("+end_time+")][("+options.altitude+")][("+lat+")][("+lng+")]&.draw=lines&.vars=time|"+options.attributes[0];
    var elid = "el"+Math.random();
    var popup = L.popup({maxWidth: 400}).setLatLng(e.latlng).setContent('<div id="'+elid+'"></div>').openOn(map);
    var fillerChart = new Highcharts.Chart({
          chart: {
              renderTo: elid,
              width: width,
              height: height,
              defaultSeriesType: 'spline'
          },
          credits: {
             text: 'loading...',
             href: url,
          },
          title: {
              text: 'Lon: '+popup.getLatLng().lng.toFixed(3)+' Lat: '+popup.getLatLng().lat.toFixed(3), 
          },
          xAxis: {
              labels: {
                categories: []
              },
          },
          yAxis: {
              title: {
                  text: options.meta.attribute[options.attributes[0]].units.value,
              }
          },
          series: []
    });
    popup.setContent(document.getElementById(elid));
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = (function(xhr,elid,options,popup) {
      popup.setContent('<div id="'+elid+'">something went wrong</div>');
      if (xhr.status !== 200) {
        console.log("http request failed with status",xhr.status);
        return;
      }
      var csv = xhr.responseText;
      // remove second label line from erddap csv
      var lines = csv.split('\n');
      lines.splice(1,1);
      var header = lines.shift().split(",");
      var coptions = {
          chart: {
              renderTo: elid,
              width: width,
              height: height,
              defaultSeriesType: 'spline'
          },
          title: {
              text: 'Lon: '+popup.getLatLng().lng.toFixed(3)+' Lat: '+popup.getLatLng().lat.toFixed(3), 
          },
          credits: {
             text: 'click to download csv',
             href: url,
          },
          xAxis: {
              type: 'datetime',
              labels: {
                rotation: 270,
              },
          },
          yAxis: {
              title: {
                  text: options.meta.attribute[options.attributes[0]].units.value,
              }
          },
          plotOptions: {
            series: {
               cursor: 'pointer',
               point: {
                 events: {
                   click: function(){
                      map.timeDimension.setCurrentTime(this.x);
                   }
                 }
               }
            }
          },
          series: []
      };
      var data = [];
      for(var i=0;i<lines.length;i++){
         var parts = lines[i].split(",");
         if(!parts[0]){
           continue;
         }
         var date = new Date().setISO8601(parts[0]).getTime();
         var v = parseFloat(parts[4]);
         data.push([ date, v]);
      }
      coptions.series.push({name: options.meta.attribute[options.attributes[0]].standard_name.value, data: data});
      var chart = new Highcharts.Chart(coptions);
      popup.setContent(document.getElementById(elid));
    }).bind(null,xhr,elid,options,popup);
    xhr.send();
};
